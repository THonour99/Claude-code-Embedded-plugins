---
allowed-tools: Read, Write, AskUserQuestion, Glob, Grep, LS, Bash(mkdir:*), Bash(cp:*)
description: 智能检测嵌入式项目并动态生成 CLAUDE.md 规范文件（零预设模板）
---

智能检测嵌入式项目结构、IDE 配置、RTOS、中间件和代码风格，**完全基于检测结果动态生成** CLAUDE.md，不使用任何硬编码的预设值。

**核心特性**: 🔍 智能检测 | 🎯 动态生成 | 🛡️ 防幻觉 | 📊 增量更新 | ✅ 生成后验证

---

## 执行步骤

### 1. 前置检查

检查当前目录是否已存在 CLAUDE.md 文件：

1. 使用 `Read` 尝试读取 `CLAUDE.md`
2. 如果文件存在，检查是否包含增量更新标记：
   - 搜索 `<!-- AUTO-GENERATED:START -->` 和 `<!-- USER-DEFINED:START -->`
3. 根据检测结果询问用户：
   - **存在标记**：询问操作方式（更新自动生成区域（推荐）/ 全量覆盖 / 取消）
   - **不存在标记（旧格式）**：询问操作方式（迁移到新格式（推荐）/ 全量覆盖 / 取消）
   - **文件不存在**：直接进入分析步骤

---

### 2. 收集补充信息

使用 `AskUserQuestion` 询问：

1. **用户称呼**（必须）:
   - 选项：您好 / Hi / 不需要称呼 / 其他（自定义）

2. **语言偏好**（必须）:
   - 选项：中文（推荐）/ English / 跟随用户输入语言

3. **如有检测失败项**（按需）:
   - MCU 型号（如果未检测到）
   - RTOS（如果未检测到）
   - 构建工具（如果未检测到）

---

### 3. 生成 CLAUDE.md

#### 3.1 通用层（固定内容）

以下内容适用于所有嵌入式项目，保持固定：

```markdown
<!-- AUTO-GENERATED:START - 以下内容由 /project-init 自动生成，重新运行会更新 -->

# CLAUDE.md（嵌入式项目）

> 由 /project-init 智能生成

---

## Response requirement

- 每个回复前都必须包含 `{用户称呼}`.
- **{语言偏好}响应**

## 核心原则

- **简单优先**：每次改动尽可能简单，只改必须改的地方
- **不偷懒**：找根因，不做临时修补，按资深开发者标准要求自己
- **先验证**：任何关键事实不得猜测，能用文件/命令/日志验证就必须验证

## 工作流程

### 计划 → 执行 → 验证

1. **非简单任务必须先计划**（3+ 步或涉及架构决策）
   - 使用 `/plan` 模式制定计划，获得用户同意后再实施
   - 计划写到 `tasks/todo.md`，列出可勾选项
   - 如果事情跑偏，立刻停下重新规划

2. **执行时遵循项目规范**
   - 参考同层级已有实现作为模板，保持代码风格一致
   - 数据结构定义在 `data_structure.h`，遵循结构体+函数指针模式
   - 边做边标记完成项，每步给出高层次总结

3. **完成前必须验证**
   - 未证明可用之前，绝不标记任务完成
   - 跑测试、查日志、展示正确性
   - 问自己："资深工程师会认可这个吗？"

### 分析完整链路

分析任何功能时，必须追踪完整使用链路：
- 调用者 → 当前模块 → 被调用者的完整调用链
- 数据流向：从哪里来，经过哪些处理，最终到哪里去
- 跨层依赖：涉及哪些层（Service/Driver/Device/BSP）
- 配置依赖：引脚定义等

### 不确定时先问

- 缺少关键上下文时，使用 `AskUserQuestion` 提 3-7 个关键问题
- 若存在多种可能，给 2-3 个假设与快速区分方法
- 高风险改动先询问确认并给回滚方案

### 子代理策略

- 大量使用子代理，保持主上下文窗口干净
- 将调研、探索和并行分析交给子代理
- 每个子代理只负责一个任务

### Bug 修复

- 收到 bug 报告直接修，不要让人手把手带
- 锁定日志、报错、失败测试——然后解决它们

### 经验沉淀

- 用户做出任何纠正后，更新 `tasks/lessons.md`
- 会话开始时回顾与当前项目相关的经验教训


## 交互规范

- **主动提问**: 数据不足或需要决策时，必须使用 `AskUserQuestion`
- **禁止主动创建文档**: 不主动创建 *.md 文件，除非用户明确要求
- **Git 提交**: 必须先询问用户同意，提交信息包含 What/Why/How

---

## 项目概述

{此处由动态层填充}

## 构建系统

{此处由动态层填充}

## 项目架构

{此处由动态层填充}

## 命名规范

{此处由动态层填充 - 从代码检测}

## FreeRTOS 任务

{此处由动态层填充 - 仅当检测到 RTOS 时显示}

## 启动顺序

{此处由动态层填充 - 仅当能检测到清晰启动流程时显示}

## 发布订阅系统

{此处由动态层填充 - 仅当检测到时显示}

## 错误处理

{此处由动态层填充 - 仅当检测到时显示}

## 内存管理

{此处由动态层填充 - 仅当检测到自定义内存管理时显示}

## 关键数据结构

{此处由动态层填充 - 仅当检测到时显示}

## Skills 技能使用规范

{此处由动态层填充 - 仅包含已安装的 skill}

<!-- AUTO-GENERATED:END -->

<!-- USER-DEFINED:START - 以下内容由用户自定义，重新运行不会覆盖 -->

## 补充说明

> 在此添加项目特有的规范、约定或注意事项。此区域在重新运行 /project-init 时会保留。

<!-- USER-DEFINED:END -->
```

#### 3.2 动态层填充规则

**项目概述**:
```markdown
## 项目概述

**{项目名}** - {如果检测到 README 则提取描述，否则留空}

### 核心技术栈

| 项目         | 配置                  |
| ------------ | --------------------- |
| **MCU**      | {检测到的 MCU 型号}   |
| **RTOS**     | {检测到的 RTOS}       |
| **编译器**   | {检测到的编译器}      |
| **构建工具** | {检测到的构建工具}    |


**项目架构**（从实际目录生成）:
```markdown
## 项目架构

### 分层架构

{根据检测到的目录结构生成实际的架构图和调用关系}

例如检测到 CubeMX 项目:
```
Core/
├── Inc/          ← 应用头文件
├── Src/          ← 应用源码
└── Startup/      ← 启动文件
Drivers/
├── STM32xxxx_HAL_Driver/  ← HAL 库
└── CMSIS/                 ← CMSIS
Middlewares/      ← 中间件（如有）
```

例如检测到分层架构:
```
BSP (bsp/) → Device (device/) → Driver (driver/) → Service (service/)
```

### 结构体+函数指针接口模式

{使用 Grep 检测代码中是否使用此模式：搜索 `typedef struct` 配合函数指针 `(*xxx)(` 的定义}

{如果检测到此模式，生成以下内容：}

**所有层都遵循此模式**，这是项目最核心的设计规范:

```c
// 1. 头文件定义接口结构体（include/drv_xxx.h）
typedef struct {
    bool (*init)(void);
    void (*get_origin_data)(ST_XXX *data);
} {检测到的类型名};
extern {检测到的类型名} {检测到的实例名};

// 2. 源文件中所有函数声明为 static（source/drv_xxx.c）
static bool init(void);
static void get_origin_data(ST_XXX *data);

// 3. 全局实例通过 designated initializer 导出
{检测到的类型名} {检测到的实例名} = {
    .init = init,
    .get_origin_data = get_origin_data,
};
```

### Device 统一接口

{如果检测到 Device 层使用统一接口模式（read/write/ioctl），生成：}

所有设备通过 `Device` 结构体暴露统一的 `read/write/ioctl` 接口:

```c
typedef struct {
    int (*read)(int addr, void *buff, int len);
    int (*write)(int addr, void *buff, int len);
    int (*ioctl)(DevCmd cmd, int data);
} Device;
```
{如果未检测到接口模式，不显示此节}
```

**命名规范**（从代码检测生成）:
```markdown
## 命名规范


**发布订阅系统**（检测 uMCN 或类似模式）:
```markdown
## 发布订阅系统

{使用 Grep 搜索以下关键字：}
- `MCN_DEFINE` / `MCN_DECLARE` / `mcn_publish` / `mcn_subscribe` (uMCN)
- `osMessageQueueNew` / `osMessageQueuePut` / `osMessageQueueGet` (CMSIS-RTOS Queue)
- 自定义发布订阅宏或函数

{如果检测到 uMCN：}

轻量级任务间通信，定义在 `{检测到的路径}`：

```c
MCN_DEFINE(Topic_Name, sizeof(DataType));   // 定义主题
MCN_DECLARE(Topic_Name);                     // 声明外部主题
mcn_advertise(MCN_ID(Topic_Name));           // 初始化时注册
mcn_publish(MCN_ID(Topic_Name), &data);      // 发布数据
mcn_subscribe(MCN_ID(Topic_Name), &buffer);  // 订阅获取数据
```

主要主题：
{列出 3-5 个典型主题作为示例}
- `Topic_IMU_Origin` / `Topic_IMU_Filter`: IMU 原始/滤波数据
- `Topic_Nav_Data`: 导航数据

{如果未检测到发布订阅系统，不显示此节}
```

**错误处理模式**（检测错误码和处理宏）:
```markdown
## 错误处理

{使用 Grep 搜索：}
- `typedef enum` 配合 `ERROR`、`RESULT`、`STATUS`、`RET` 等关键字
- 错误处理宏如 `CHECK`、`TRY`、`ASSERT` 等

### 返回码

{如果检测到错误码枚举，列出：}

```c
typedef enum {
    {枚举名}_EOK = 0,      // 成功
    {枚举名}_ERROR = 1,    // 通用错误
    {枚举名}_ETIMEOUT = 2, // 超时
    // ... 其他检测到的错误码
} {检测到的类型名};
```

**关键数据结构**（检测数据定义文件）:
```markdown
## 关键数据结构

{使用 Glob 搜索：}
- `data_structure.h`、`types.h`、`typedef.h` 等数据定义文件
- 或搜索包含大量 `typedef struct` 的头文件

{如果检测到数据定义文件：}

定义在 `{检测到的文件路径}`，使用 `#pragma pack(1)`:

{列出 3-5 个核心数据结构作为示例}
- `{结构体名1}`: {从命名或注释推断用途}
- `{结构体名2}`: {从命名或注释推断用途}

{示例输出：}
- `ST_IMU`: IMU 传感器数据
- `ST_BARO`: 气压计数据

{如果未检测到集中的数据定义文件，不显示此节}
```

**关键配置文件**（扫描实际存在的文件）:
```markdown
## 关键配置文件

| 配置项     | 文件位置                    |
| ---------- | --------------------------- |
{扫描项目中实际存在的配置文件，如:}
| MCU 定义   | {实际路径}                  |
| 引脚定义   | {实际路径}                  |
| RTOS 配置  | {实际路径}                  |
```

**Skills 映射**（仅包含已安装的）:
```markdown
## Skills 技能使用规范

| 触发场景     | 关键词                  | 推荐技能                    | 状态   |
| ------------ | ----------------------- | --------------------------- | ------ |
{仅列出已安装的 skill，例如:}
| 嵌入式调试   | HardFault、崩溃、栈溢出 | `embedded-debug-assistant`  | ✅ 已安装 |
| 驱动性能分析 | DMA优化、CPU占用        | `embedded-perf-analyzer`    | ✅ 已安装 |

{如果没有检测到任何已安装的 skill，显示:}
> 未检测到已安装的嵌入式专用 Skills。如需使用，请先安装。
```

---

### 4. 生成后验证

生成 CLAUDE.md 后执行验证：

1. **文件路径验证**:
   - 检查所有引用的文件路径是否存在
   - 对不存在的路径输出警告

2. **MCU 验证**:
   - 如果检测到 MCU 型号，检查对应的 HAL 头文件是否存在

3. **Skills 验证**:
   - 确认列出的 Skills 确实已安装

4. **输出验证报告**:
```
📋 验证报告:
   ✅ 项目文件: {路径} - 存在
   ✅ 链接脚本: {路径} - 存在
   ⚠️ 配置文件: {路径} - 不存在（已从列表移除）
   ✅ Skills: {N} 个已验证
```

---

### 5. 输出结果

```
✅ CLAUDE.md 生成完成！

📋 检测结果:
   - MCU: {检测到的 MCU 型号 或 "未检测到（用户指定: xxx）"}
   - RTOS: {检测到的 RTOS}
   - 构建工具: {检测到的构建工具}
   - 中间件: {检测到的中间件列表 或 "无"}
   - 代码风格: {检测到的命名模式}

📂 文件已创建: ./CLAUDE.md

📝 增量更新标记已添加:
   - AUTO-GENERATED 区域: 重新运行会更新
   - USER-DEFINED 区域: 重新运行会保留

💡 建议:
   - 检查生成的命名规范是否准确
   - 在 USER-DEFINED 区域添加项目特有规范
   - 如有检测不准确的内容，可手动修正
```

---

## 增量更新逻辑

当检测到已存在的 CLAUDE.md 且包含增量更新标记时：

1. 读取现有文件
2. 提取 `<!-- USER-DEFINED:START -->` 和 `<!-- USER-DEFINED:END -->` 之间的内容
3. 重新执行项目分析
4. 生成新的 AUTO-GENERATED 区域
5. 保留原有的 USER-DEFINED 区域
6. 写入文件

---

## 注意事项

1. **零预设原则**: 不使用任何硬编码的前缀、路径或模式，全部从项目检测
2. **失败优雅处理**: 任何检测失败的项目标记为"未检测到"，不做假设
3. **验证闭环**: 生成后必须验证所有引用的文件路径
4. **用户可控**: USER-DEFINED 区域永不覆盖
5. **跨平台兼容**: 不依赖特定平台的命令（如 date）
