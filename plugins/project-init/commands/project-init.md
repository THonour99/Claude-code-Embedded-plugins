---
allowed-tools: Read, Write, AskUserQuestion, Bash(date:*), Glob, Grep
description: 智能分析嵌入式项目并生成 CLAUDE.md 规范文件（STM32/FreeRTOS/裸机）
---

智能分析嵌入式项目结构和配置文件,自动推断芯片型号、RTOS、外设配置等信息,**只对无法确定的信息进行询问**,最终生成嵌入式项目的 CLAUDE.md 开发规范文件。

**核心特性**: 🔍 智能分析 | 💡 按需询问 | 🎯 数据优先 | 🌐 跨平台 | 🔧 嵌入式专用

---

## 内置模板

以下是用于生成嵌入式项目 CLAUDE.md 的内置模板：

```template
# CLAUDE.md 模板（嵌入式）

> 用于在嵌入式项目中快速建立开发规范和最佳实践。使用时请填充 `[占位符]` 部分。

---

## Response requirement

- 每个回复前都必须包含 `[用户称呼]`.
- **完整链路分析**: 分析任何功能时，必须追踪完整调用链和数据流（详见"调用链路分析"章节）
- **遵循层职责边界**: 修改代码前必须确认当前操作属于哪一层（详见"架构规则"章节）
- **遵循项目代码习惯**: 修改前先分析现有代码规范（数据结构位置、接口模式、文件组织）
- **防幻觉工作流**:
  - 关键事实必须验证，不得猜测
  - 缺少关键上下文时，使用 `AskUserQuestion` 询问后再继续
  - 输出中标注：已验证/未验证，给出依据来源
  - 只做最小必要改动，高风险改动先询问确认
  - 方案必须切实可行，禁止生成无法实现的内容
- **代码修改流程**: 修改前必须先使用 `/plan` 模式制定计划，获得用户同意后再实施

## 核心原则

- **KISS**: 保持简单，拒绝过度设计
- **DRY**: 避免重复，优先复用现有代码
- **SoC**: 关注点分离，各层各司其职
- **最小影响**: 只改必须改的地方，避免引入 bug

## 工作流程编排

1. **计划模式默认**: 非简单任务（3+ 步或涉及架构决策）进入计划模式
2. **子代理策略**: 将调研、探索和并行分析交给子代理，保持主上下文干净
3. **自我改进**: 用户纠正后更新 `tasks/lessons.md`，防止重复犯错
4. **完成前验证**: 未证明可用之前，绝不标记任务完成
5. **自主修复**: 收到 bug 报告直接修复，不等手把手指导

## 任务管理

1. 把计划写到 `tasks/todo.md`，列出可勾选项
2. 开始实现前先确认计划
3. 边做边标记完成项
4. 纠正后更新 `tasks/lessons.md`

---

## 项目概述

**[项目名称]** - [项目一句话描述]

### 核心技术栈

| 项目         | 配置                                            |
| ------------ | ----------------------------------------------- |
| **MCU**      | [芯片型号，如 STM32H743VI (Cortex-M7 @ 480MHz)] |
| **RTOS**     | [FreeRTOS / RT-Thread / 裸机]                   |
| **编译器**   | [ARM Compiler V5/V6 / GCC ARM]                  |
| **构建工具** | [Keil MDK / IAR / CMake + GCC]                  |

### 项目架构

```
上层应用 (集成方)
      ↓
┌─────────────────────────────────────────────────┐
│  Service   (platform/service/)   ← 传感器服务   │
│  Driver    (platform/driver/)    ← 外设驱动     │
│  Device    (platform/device/)    ← 设备抽象     │
│  BSP       (platform/bsp/)       ← HAL封装      │
│  Arch      (platform/arch/)      ← HAL库/启动   │
└─────────────────────────────────────────────────┘
      ↑
   Board     (platform/board/)     ← 引脚/特性配置
```

**依赖规则**: Service → Driver → Device → BSP → Arch（禁止反向依赖）

---

## 构建系统

- **项目文件**: `[项目文件路径]`
- **编译器**: [编译器版本]
- **编译宏**: `[宏定义列表]`

---

## 架构规则（强制）

### 层职责定义

| 层          | 职责                          | 禁止行为                   |
| ----------- | ----------------------------- | -------------------------- |
| **Service** | 统一接口封装，多实例管理路由  | 直接操作硬件寄存器         |
| **Driver**  | 具体芯片/传感器的驱动逻辑     | 向上依赖 Service，跨层调用 |
| **Device**  | 外设抽象（SPI/I2C/UART/GPIO） | 包含业务逻辑               |
| **BSP**     | 封装 HAL 库，提供板级接口     | 直接暴露 HAL 函数给上层    |
| **Board**   | 定义引脚、特性、设备映射      | 包含实现代码               |

### 命名规范

| 类型     | 规范                        | 示例                        |
| -------- | --------------------------- | --------------------------- |
| 文件名   | snake_case，层前缀          | `drv_bmi088.c`, `srv_imu.c` |
| 层前缀   | `bsp_`/`dev_`/`drv_`/`srv_` | `bsp_uart1.c`               |
| 数据结构 | `ST_` 前缀                  | `ST_IMU`, `ST_GNSS`         |
| 枚举     | `EM_` 前缀                  | `EM_RC_STATE`               |
| 返回值   | 统一错误码 `RY_RESULT`      | `RY_EOK`, `RY_ERROR`        |

### 禁止行为清单

- ❌ ISR 中执行阻塞操作或动态内存分配
- ❌ 跨层直接调用（必须经过相邻层）
- ❌ 反向依赖（低层模块依赖高层模块）
- ❌ 在非 DMA 安全的内存区域使用 DMA
- ❌ 跨层职责混淆（如 Driver 层实现 Service 层逻辑）
- ❌ 版本迭代（v1/v2/v3），必须就地更新
- ❌ 提交信息包含 AI 工具标识

### 接口设计模式（结构体+函数指针）

```c
// Driver 层 - handle 支持多实例
typedef struct {
    RY_RESULT (*init)(void *handle);
    RY_RESULT (*get_origin_data)(void *handle, ST_XXX *data);
    bool is_init_success;
} Drv_XXX;

// Service 层 - ID 路由到驱动实例
typedef struct {
    RY_RESULT (*init)(void);
    RY_RESULT (*get_origin_data)(const uint8_t id, ST_XXX *data);
    uint8_t (*get_supported_cnt)(void);
} Srv_XXX;
```

---

## 核心开发实践

### 调用链路分析（修改代码前必须完成）

```
应用层 → Service → Driver → Device → BSP → HAL → 硬件寄存器
中断/DMA ← ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

**必须分析的要点**:
- **调用者/被调用者链**: 上下游模块关系
- **数据流向**: 从传感器到应用层的完整路径
- **中断路径**: 中断触发源 → ISR → 回调 → 数据处理
- **配置依赖**: board_features、board_mapping、board_pins

**问题定位原则**: 禁止只看当前报错就下结论，必须追踪数据完整路径找到根因。

### 方案设计检查清单

开始编码前必须完成：
- [ ] 已完整追踪调用链路
- [ ] 已确认修改在正确的层进行
- [ ] 已回答 KISS 四问（真问题？更简单方法？会破坏什么？真的需要？）
- [ ] 已收集充足数据支撑方案
- [ ] 已获得用户审批确认

### 质量门

| 阶段              | 检查点                                       |
| ----------------- | -------------------------------------------- |
| **Gate 0 立项**   | 需求边界明确、KISS 四问已回答                |
| **Gate 1 方案**   | 调用链分析完整、层职责边界确认、风险分析明确 |
| **Gate 2 编码前** | grep 检查无重复定义、分层边界清晰            |
| **Gate 3 测试**   | 分层测试完成、边界条件已测试                 |

---

## Skills 技能使用规范

| 触发场景     | 关键词                  | 必须使用的技能             |
| ------------ | ----------------------- | -------------------------- |
| 嵌入式调试   | HardFault、崩溃、栈溢出 | `embedded-debug-assistant` |
| 驱动性能分析 | DMA优化、CPU占用        | `embedded-perf-analyzer`   |
| HAL库检查    | HAL使用、STM32 HAL      | `hal-check`                |
| RTOS分析     | FreeRTOS、任务优先级    | `rtos-analyze`             |

**强制规则**: 识别到上述场景时，必须调用对应技能，禁止跳过。

---

## 关键配置文件

| 配置项     | 文件位置                                         |
| ---------- | ------------------------------------------------ |
| 芯片选择   | `platform/arch/interface/hal_adapter.h`          |
| 内存段定义 | `platform/arch/interface/arch_memory.h`          |
| 引脚定义   | `platform/board/[chip]/[board]/board_pins.h`     |
| 特性配置   | `platform/board/[chip]/[board]/board_features.h` |
| 数据结构   | `platform/interface/data_structure.h`            |

---

## 内存配置

| 内存区域 | 用途        | 宏                 |
| -------- | ----------- | ------------------ |
| DTCM     | 高速变量/栈 | `FAST_RAM_SECTION` |
| AXI_SRAM | DMA缓冲     | `AXI_RAM_SECTION`  |

---

## 交互规范

- **中文响应**: 所有响应使用中文
- **主动提问**: 数据不足或需要决策时，必须使用 `AskUserQuestion`
- **禁止主动创建文档**: 不主动创建 *.md 文件，除非用户明确要求
- **Git 提交**: 必须先询问用户同意，提交信息包含 What/Why/How

---

**最后更新**: [日期]
```

---

## 执行步骤

### 1. 前置检查

检查当前目录是否已存在 CLAUDE.md 文件：
- 如果存在，使用 AskUserQuestion 询问：备份后覆盖（推荐）/ 直接覆盖 / 取消操作
- 如果用户选择取消，立即终止

### 2. 项目分析

**核心原则**: 数据驱动，避免猜测。

#### a. 检测项目类型

| 项目类型 | 检测文件                | 提取信息                    |
| -------- | ----------------------- | --------------------------- |
| Keil MDK | `*.uvprojx`, `*.uvproj` | ProjectName, Device, Define |
| IAR      | `*.ewp`, `*.eww`        | 项目名、MCU、编译器         |
| CMake    | `CMakeLists.txt`        | project(), 工具链           |
| CubeMX   | `*.ioc`                 | MCU、外设、时钟配置         |

#### b. 检测 RTOS

- FreeRTOS: `**/FreeRTOS*.h`, Grep "FreeRTOS"
- RT-Thread: `**/rtthread.h`, Grep "rt_thread"
- 裸机: 以上都未检测到

#### c. 检测架构

- 分层架构: `**/service/**/*.c`, `**/driver/**/*.c`, `**/device/**/*.c`
- Board 配置: `**/board_*.h`

#### d. 收集配置信息

**必须询问用户称呼**（使用 AskUserQuestion）：
- 选项：您好 / Hi / 不需要称呼 / 其他（自定义）

### 3. 生成 CLAUDE.md

根据分析结果填充模板：
1. 填充用户称呼
2. 填充项目概述（MCU、RTOS、框架）
3. 填充架构信息
4. 填充配置文件表
5. 填充 Skills 映射表

### 4. 输出结果

```
✅ CLAUDE.md 生成完成！

📋 项目信息:
   - MCU: [检测到的 MCU 型号]
   - RTOS: [检测到的 RTOS]
   - 构建工具: [检测到的构建工具]

📂 文件已创建: ./CLAUDE.md
```

---

## 注意事项

1. **数据优先**: 优先使用项目实际数据，避免猜测
2. **按需询问**: 只对无法推断的信息询问用户
3. **嵌入式特化**: 模板针对嵌入式开发场景优化
