---
allowed-tools: Read, Write, AskUserQuestion, Bash(date:*), Glob, Grep
description: 智能分析嵌入式项目并生成 CLAUDE.md 规范文件（STM32/FreeRTOS/裸机）
---

智能分析嵌入式项目结构和配置文件,自动推断芯片型号、RTOS、外设配置等信息,**只对无法确定的信息进行询问**,最终生成嵌入式项目的 CLAUDE.md 开发规范文件。

**核心特性**:
- 🔍 **智能分析**: 自动检测 MCU 型号、RTOS、外设驱动
- 💡 **按需询问**: 只对无法推断的信息询问用户
- 🎯 **数据优先**: 优先使用项目实际数据,避免猜测
- 🌐 **跨平台**: 完全兼容 Windows / macOS / Linux
- 🔧 **嵌入式专用**: 针对 STM32/FreeRTOS/裸机等嵌入式场景优化

---

## 内置模板

以下是用于生成嵌入式项目 CLAUDE.md 的内置模板：

```template
# CLAUDE.md 模板（嵌入式）

> 用于在嵌入式项目中快速建立开发规范和最佳实践。使用时请填充 `[占位符]` 部分。

---

## Response requirement

- 每个回复前都必须包含 `[用户称呼]`.
- **分析完整链路**: 在分析任何功能、模块或组件时，必须追踪其完整的使用链路，包括：
  - 调用者 → 当前模块 → 被调用者的完整调用链
  - 数据流向：数据从哪里来，经过哪些处理，最终到哪里去
  - 跨层依赖：涉及哪些层（Service/Driver/Device/BSP），如何交互
  - 配置依赖：board_features、board_mapping、引脚定义等的关联
  - 不要仅分析当前文件或模块，要理解其在整个系统中的位置和作用
- **追踪完整数据使用链**: 分析代码或查找问题时，禁止只关注当前代码片段：
  - **数据来源**: 数据从哪个传感器/外设/接口产生？原始格式是什么？
  - **数据传递**: 数据经过哪些函数/模块处理？每一步做了什么转换？
  - **数据消费**: 数据最终被谁使用？使用方式是什么？
  - **错误传播**: 如果数据异常，会影响哪些下游模块？
  - **必须做到**: 从数据产生点追踪到最终消费点，理解完整生命周期
  - **禁止行为**: 禁止只看当前函数就下结论，必须追踪上下游
- **严格遵守层职责边界**: 在分析和修改代码时，必须明确每一层的职责边界：
  - **Service层**: 只负责多实例管理和统一接口封装，禁止直接操作硬件
  - **Driver层**: 只负责具体芯片/传感器的驱动逻辑，禁止向上依赖 Service
  - **Device层**: 只负责外设抽象（SPI/I2C/UART/GPIO），禁止包含业务逻辑
  - **BSP层**: 只负责封装 HAL 库，禁止直接暴露 HAL 函数给上层
  - **Board**: 只负责定义配置（引脚/特性/映射），禁止包含实现代码
  - 修改代码前必须确认当前操作属于哪一层，禁止跨层职责混淆
  - 如发现现有代码违反层职责边界，应先报告问题再决定是否修复
- **遵循项目代码习惯**: 在修改或添加文件时，必须先分析项目的现有代码规范和习惯，包括：
  - 数据结构定义位置（如 `ST_XXX` 必须定义在 `data_structure.h`）
  - 接口函数实现方式（如结构体+函数指针模式）
  - 文件组织结构（interface/ 和 src/ 目录规则）
  - 初始化流程和错误处理模式
  - 参考同层级的已有实现作为模板，保持代码风格一致
  - 禁止随意实现，必须与现有代码保持统一风格
- **请严格执行"防幻觉工作流"**：
  - 任何关键事实不得猜测；能用文件/命令/日志验证就必须验证。
  - 如果缺少关键上下文，先提 3-7 个最关键问题或列出需要我提供的材料，必须使用`AskUserQuestion`询问后再继续。
  - 输出中明确标注：已验证/未验证，并给出依据来源。
  - 只做最小必要改动；改动后给 diff 摘要 + 可复现验证步骤；高风险改动先询问确认并给回滚方案。
  - 若存在多种可能，给 2-3 个假设与快速区分方法，必须使用`AskUserQuestion`询问后再继续。
  - **方案诚实性原则**：所有提出的方案必须是切实可行的，禁止为迎合用户期望而生成"看似合理但无法实现"的内容。
    - 如果需求在当前条件下无法实现，必须诚实说明技术限制和原因，使用 `AskUserQuestion` 确认用户是否接受替代方案
    - 如果存在更好的替代方案，应主动提出而非盲从用户的原始思路
    - 不得生成未经验证的"占位代码"或伪实现来假装完成任务
- **代码修改流程**：
  - 修改代码前必须先使用 `/plan` 模式制定修改计划，获得用户同意后再实施修改
  - 对于不确定的问题，必须使用 `AskUserQuestion` 询问用户后再继续

## 核心原则

- **简单优先**：每次改动尽可能简单。尽量影响最少代码。
- **不偷懒**：找根因。不做临时修补。按资深开发者标准要求自己。
- **最小影响**：只改必须改的地方。避免引入 bug。

## 工作流程编排

### 1. 计划模式默认规则

- 对任何**非简单**任务进入计划模式（3+ 步或涉及架构决策）
- 如果事情跑偏，立刻**停下**并重新规划——不要继续硬推
- 验证步骤也要用计划模式，不只是构建/实现
- 提前写出详细规格以减少歧义

### 2. 子代理策略

- 大量使用子代理，保持主上下文窗口干净
- 将调研、探索和并行分析交给子代理
- 对复杂问题，通过子代理投入更多算力
- 每个子代理只负责一个任务，便于专注执行

### 3. 自我改进循环

- 用户做出**任何**纠正后：按该模式更新 `tasks/lessons.md`
- 给自己写规则，防止重复犯同样的错
- 对这些经验教训进行无情迭代，直到错误率下降
- 在会话开始时回顾与当前项目相关的经验教训

### 4. 完成前验证

- 未证明可用之前，绝不标记任务完成
- 需要时对比主版本与改动后的行为差异
- 问自己："资深工程师会认可这个吗？"
- 跑测试、查日志、展示正确性

### 5. 追求优雅（平衡）

- 对非简单改动：停一下，问"有没有更优雅的方式？"
- 如果修复看起来很 hack："以我现在掌握的一切知识，实现那个优雅的方案"
- 简单、明显的修复可以跳过——别过度工程
- 在展示之前先挑战/审视自己的工作

### 6. 自主修复 Bug

- 收到 bug 报告：直接修。不要让人手把手带
- 锁定日志、报错、失败测试——然后把它们解决
- 不要让用户为你做上下文切换
- 编译报错就去修，不要等别人告诉你怎么修

## 任务管理

1. **先计划**：把计划写到 `tasks/todo.md`，并列出可勾选项
2. **验证计划**：开始实现前先确认
3. **跟踪进度**：边做边标记完成项
4. **说明变更**：每一步给出高层次总结
5. **记录结果**：在 `tasks/todo.md` 添加复盘/评审部分
6. **沉淀经验**：纠正后更新 `tasks/lessons.md`

---

## 项目概述

**[项目名称]** - [项目一句话描述]

### 核心技术栈

- **MCU**: [芯片型号，如 STM32H743VI (Cortex-M7 @ 480MHz)]
- **RTOS**: [实时系统，如 FreeRTOS / RT-Thread / 裸机]
- **编译器**: [工具链，如 ARM Compiler V5/V6 / GCC ARM]
- **开发语言**: C / C++ (嵌入式子集)
- **构建工具**: [Keil MDK / IAR / CMake + GCC]

### 项目架构

```
上层应用 (集成方)
      ↓
┌─────────────────────────────────────────────────┐
│  Service   (platform/service/)   ← 传感器服务   │
│      ↓                                          │
│  Driver    (platform/driver/)    ← 外设驱动     │
│      ↓                                          │
│  Device    (platform/device/)    ← 设备抽象     │
│      ↓                                          │
│  BSP       (platform/bsp/)       ← HAL封装      │
│      ↓                                          │
│  Arch      (platform/arch/)      ← HAL库/启动   │
└─────────────────────────────────────────────────┘
      ↑
   Board     (platform/board/)     ← 引脚/特性配置
```

**依赖规则**: Service → Driver → Device → BSP → Arch（禁止反向依赖）

**关键模块**：
- **[模块1]**: [路径] - [说明]
- **[模块2]**: [路径] - [说明]

---

## 构建系统

**使用 [Keil MDK / IAR / CMake] 构建**：
- 项目文件: `[项目文件路径]`
- 编译器: [编译器版本]
- 清理编译: [清理命令或脚本]

**编译宏**: `[宏定义列表]`

---

## 测试规范（嵌入式）

- 按层分级测试：BSP → Device → Driver → Service
- 测试文件位于 `[测试目录路径]`:
  - `unit_test_bsp.c` - BSP 层测试
  - `unit_test_device.c` - Device 层测试
  - `unit_test_driver.c` - Driver 层测试
  - `unit_test_service.c` - Service 层测试
- 测试入口统一管理
- 支持硬件在环 (HIL) 测试
- Mock 外部传感器/外设响应

---

## 架构规则（强制）

### 层职责定义

- **Service层**: ✅ 提供统一的传感器服务接口，管理多实例路由 / ❌ 禁止直接操作硬件寄存器
- **Driver层**: ✅ 实现具体芯片/传感器的驱动逻辑 / ❌ 禁止跨层调用 Service
- **Device层**: ✅ 提供外设抽象（SPI/I2C/UART/GPIO等） / ❌ 禁止包含业务逻辑
- **BSP层**: ✅ 封装 HAL 库，提供板级接口 / ❌ 禁止直接暴露 HAL 函数
- **Board**: ✅ 定义引脚、特性、设备映射 / ❌ 禁止包含实现代码

### 开发规则

1. **命名规范**:
   | 类型 | 规范 | 示例 |
   |------|------|------|
   | 文件名 | snake_case，层前缀 | `drv_bmi088.c`, `srv_imu.c` |
   | BSP/Device/Driver/Service | 前缀 `bsp_`/`dev_`/`drv_`/`srv_` | `bsp_uart1.c` |
   | 数据结构 | `ST_` 前缀 | `ST_IMU`, `ST_GNSS` |
   | 枚举 | `EM_` 前缀 | `EM_RC_STATE` |
   | 返回值类型 | 统一错误码 | `RY_RESULT`: `RY_EOK`, `RY_ERROR`, `RY_EINVAL` |
   | 头文件保护 | `__XXX_H` | `#ifndef __DRV_ESC_H` |

2. **依赖管理** - 严格遵循分层依赖规则，禁止反向依赖
3. **错误处理** - 使用统一错误码 `RY_RESULT`，逐层传递错误
4. **版本控制** -
   - Git 提交必须使用 AskUserQuestion 工具询问用户同意
   - 提交消息必须包含：
     - 问题描述（What）
     - 根本原因（Why）
     - 修复内容（How）
     - 技术细节（Details）
     - 影响范围（Impact）
   - **严格禁止**包含以下内容：
     - `🤖 Generated with [Claude Code](https://claude.com/claude-code)`
     - `Co-Authored-By: Claude <noreply@anthropic.com>`
     - 其他任何 AI 工具的标识或署名
5. **禁止行为**:
   - 禁止在 ISR 中执行阻塞操作
   - 禁止在 ISR 中进行动态内存分配
   - 禁止跨层直接调用（必须经过相邻层）
   - 禁止在非 DMA 安全的内存区域使用 DMA
   - 禁止跨层职责混淆（如在 Driver 层实现 Service 层逻辑）
   - 禁止反向依赖（低层模块禁止依赖高层模块）

### Claude Code 工具使用规范

**AI 必须使用的工具**：
- **AskUserQuestion**: 数据不足或需要决策时，必须主动询问用户
- **TodoWrite**: 跟踪多步骤任务的进度，及时更新任务状态
- **Read/Grep/Glob**: 修改前必须先分析现有代码，避免重复定义
- **Plan**: 设计实施方案时，必须使用 Plan 工具进行规划和架构设计

### Skills 技能使用规范（强制）

Skills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。

#### 强制使用场景映射表

> **使用说明**: 根据项目实际可用的 Skills 填充下表。通过 `<available_skills>` 列表获取当前环境可用技能。

| 触发场景 | 关键词识别 | 必须使用的技能 |
|---------|-----------|--------------|
| 嵌入式调试 | HardFault、崩溃、栈溢出、调试 | `embedded-debug-assistant` |
| 驱动性能分析 | DMA优化、驱动性能、CPU占用 | `embedded-perf-analyzer` |
| HAL库检查 | HAL使用、STM32 HAL | `hal-check` |
| RTOS分析 | FreeRTOS、任务分析、优先级 | `rtos-analyze` |
| [场景N] | [关键词...] | `[skill-name]` |

**常见嵌入式场景类型参考**：
- 调试类：HardFault 分析、栈溢出检测、内存泄漏
- 性能类：DMA 优化、中断延迟、CPU 占用分析
- 驱动类：传感器驱动、通信协议、外设配置
- RTOS 类：任务调度、优先级反转、死锁检测

#### 强制触发规则

**以下场景必须调用对应技能，禁止跳过**：

1. **嵌入式调试**（触发 `embedded-debug-assistant`）
   - 分析 HardFault、MemManage、BusFault 等异常
   - 调试栈溢出、内存越界问题
   - 分析 FreeRTOS 任务崩溃
   - 用户提及"崩溃"、"调试"、"HardFault"

2. **驱动性能分析**（触发 `embedded-perf-analyzer`）
   - 分析 DMA 使用效率
   - 检测轮询 vs 中断模式
   - 评估数据缓冲策略
   - 用户提及"性能优化"、"DMA"、"CPU 占用"

#### 技能调用检查清单

在完成任务前，必须检查：
- [ ] 是否识别到上述强制触发场景？
- [ ] 是否已调用对应的必需技能？
- [ ] 如未调用，是否有合理理由？（需向用户说明）

#### 禁止行为

- ❌ **禁止**在强制场景下不调用对应技能
- ❌ **禁止**用文字描述替代专业分析输出
- ❌ **禁止**跳过专业技能直接输出低质量结果

#### 技能调用语法

```
使用 Skill 工具，参数 skill 设置为技能名称：
- embedded-debug-assistant（嵌入式调试）
- embedded-perf-analyzer（驱动性能分析）
- hal-check（HAL 库检查）
- rtos-analyze（RTOS 分析）
- [根据 <available_skills> 列表填充]
```

#### 动态技能发现流程

1. **识别任务类型**：分析用户需求，判断是否需要专业技能支持
2. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能
3. **匹配场景映射**：根据上表的场景映射，确定必须调用的技能
4. **调用技能**：使用 `Skill` 工具调用对应技能

**Token 管理规范（强制）**：

在开始每个 todo 任务前，必须评估剩余 token 是否足够完成该任务：

1. **评估标准**：
   - 当前剩余 token < 30000：存在风险
   - 当前剩余 token < 20000：高风险
   - 当前剩余 token < 10000：极高风险

2. **风险处理流程**：

   **如果存在风险**，必须使用 AskUserQuestion 工具询问用户：

   ```yaml
   question: "⚠️ Token 预警：当前剩余 [X] tokens，即将开始「[Todo任务名称]」可能存在 token 不足风险。您希望如何处理？"
   header: "Token 管理"
   multiSelect: false
   options:
     - label: "继续执行当前任务"
       description: "继续完成当前任务，可能需要在新会话中继续未完成的工作"
     - label: "生成进度总结文档"
       description: "生成包含当前进度总结和剩余待办事项实施方案的文档，便于在新会话中继续"
   ```

3. **生成进度总结文档**（用户选择选项 2 时）：

   创建文档：`docs/progress/YYYY-MM-DD-HH-MM-[任务名称]-进度总结.md`

   文档必须包含：
   ```markdown
   # [任务名称] - 进度总结与实施方案

   **创建时间**: YYYY-MM-DD HH:MM
   **当前状态**: 进行中
   **完成度**: X/Y 个任务

   ---

   ## 一、已完成任务

   ### 1.1 任务清单
   - [x] 任务 1 - 完成情况描述
   - [x] 任务 2 - 完成情况描述
   - [x] 任务 3 - 完成情况描述

   ### 1.2 关键成果
   - **成果 1**: 具体内容和路径
   - **成果 2**: 具体内容和路径
   - **成果 3**: 具体内容和路径

   ### 1.3 已修改文件
   ```
   path/to/file1.c - 修改内容描述
   path/to/file2.h - 修改内容描述
   ```

   ---

   ## 二、剩余待办任务

   ### 2.1 待办清单
   - [ ] 任务 4 - 详细描述
   - [ ] 任务 5 - 详细描述
   - [ ] 任务 6 - 详细描述

   ### 2.2 实施方案

   #### 任务 4: [任务名称]
   **目标**: [具体目标]
   **步骤**:
   1. [详细步骤 1]
   2. [详细步骤 2]
   3. [详细步骤 3]

   **需要修改的文件**:
   - `path/to/file1.c` - [修改说明]
   - `path/to/file2.h` - [修改说明]

   **注意事项**:
   - [注意点 1]
   - [注意点 2]

   ---

   ## 三、技术背景和上下文

   ### 3.1 项目架构
   [关键架构信息]

   ### 3.2 技术栈
   [MCU、RTOS、编译器等信息]

   ### 3.3 重要约束
   - [约束 1]
   - [约束 2]

   ### 3.4 已知问题
   - [问题 1 及解决方案]
   - [问题 2 及解决方案]

   ---

   ## 四、继续工作指南

   ### 4.1 快速启动
   在新会话中执行以下步骤：
   1. 阅读本文档了解当前进度
   2. 使用 TodoWrite 工具恢复任务列表
   3. 从「任务 4」开始继续执行

   ### 4.2 验证检查清单
   开始前请确认：
   - [ ] 已理解所有已完成任务的内容
   - [ ] 已查看所有修改过的文件
   - [ ] 已理解剩余任务的实施方案
   - [ ] 已了解技术背景和约束

   ---

   **🤖 Generated with Claude Code**
   ```

4. **文档生成后**：
   - 输出文档路径
   - 提示用户在新会话中使用 `@文档路径` 继续工作
   - 优雅结束当前会话

**最佳实践**：
- 定期评估 token 使用情况
- 在大型任务开始前进行评估
- 预留至少 15000 tokens 的安全边际
- 及时保存进度，避免工作丢失

---

## AI 工作流程与质量门（强制）

### 工作流程总览

```
需求输入
   ↓
A. 立项/澄清（Gate 0）
   ↓  KISS + YAGNI + AskUserQuestion
   ↓
B. 方案设计（Gate 1）
   ↓  分层架构 + 调用链分析 + 配置依赖
   ↓
C. 编码前置（Gate 2）
   ↓  DRY + 分层职责 + 代码风格检查
   ↓
D. 编码实现
   ↓  结构体+函数指针 + 中断安全 + 内存安全
   ↓
E. 测试与验收（Gate 3）
   ↓  分层测试 + HIL测试
   ↓
开发完成 ✅
（烧录与调试不在此范围）
```

---

### A. 立项/澄清阶段（Gate 0）

**目标**: 明确需求边界，拒绝过度设计

**使用原则**:
- **KISS + YAGNI** → 先砍需求，确认功能必要性
- **AskUserQuestion** → 明确边界与约束

**输出**:
- 需求边界清晰
- 最小方案草图
- 走审批流程

**质量门 Gate 0：问题澄清**
- [ ] 已使用 AskUserQuestion 收敛需求与约束
- [ ] KISS 四问已回答（特别是"真的需要这个功能吗？"）
- [ ] 需求边界明确，无歧义

---

### B. 方案设计阶段（Gate 1）

**目标**: 设计符合分层架构的方案

**使用原则**:
- **分层架构** → 明确 Service/Driver/Device/BSP 边界
- **调用链分析** → 完整追踪数据流和控制流

**输出**:
- 方案文档（`docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`）
- 必须包含：
  - 完整调用链路分析（Service → Driver → Device → BSP）
  - KISS 四问的回答
  - 内存/性能影响评估
  - 中断安全分析
  - 风险分析和缓解措施

**质量门 Gate 1：方案评审**
- [ ] 方案文档已提交
- [ ] 调用链路分析完整
- [ ] 层职责边界已确认（无跨层混淆、无反向依赖）
- [ ] KISS 四问已回答
- [ ] 内存/性能影响已评估
- [ ] 中断安全已分析
- [ ] 风险与缓解措施明确
- [ ] 已获得用户审批

---

### C. 编码前置阶段（Gate 2）

**目标**: 确保代码质量，避免重复实现

**使用原则**:
- **DRY** → 全局检索避免重复（使用 grep）
- **分层职责** → 划清各层边界
- **代码风格** → 检查现有代码风格

**输出**:
- 代码重复检查报告
- 分层职责明确
- 参考的现有代码示例

**质量门 Gate 2：实现前检查**
- [ ] 已使用 grep 全局检索，无重复定义
- [ ] 分层边界清晰，职责明确
- [ ] 已确认修改不违反层职责边界
- [ ] 已找到可参考的同层级代码
- [ ] 接口契约明确

---

### D. 编码实现阶段

**目标**: 高质量嵌入式代码实现

**使用原则**:
- **结构体+函数指针** → 统一接口设计模式
- **中断安全** → 临界区保护、避免 ISR 阻塞
- **内存安全** → DMA 对齐、内存段选择

**输出**:
- 高质量代码
- 符合项目代码风格
- 中断安全保障

**关键检查**:
- [ ] 接口设计符合结构体+函数指针模式
- [ ] 命名规范符合项目要求
- [ ] 数据结构定义在正确位置
- [ ] 中断安全措施到位
- [ ] 代码在正确的层实现，无跨层职责混淆

---

### E. 测试与验收阶段（Gate 3）

**目标**: 确保代码质量和功能正确性

**使用原则**:
- **分层测试** → BSP → Device → Driver → Service
- **HIL测试** → 硬件在环验证

**输出**:
- 测试报告（`docs/test/YYYY-MM-DD-HH-MM-功能名称-测试报告.md`）
- 测试结果

**质量门 Gate 3：测试门**
- [ ] 分层测试已完成
- [ ] 边界条件已测试
- [ ] 错误处理已验证
- [ ] 测试报告已生成

---

## 核心开发实践（强制）

### 1. 代码修改前的分析（强制）

**所有代码修改前，必须先完成深度分析，理解项目架构后再设计方案。**

#### 调用链路分析要点（嵌入式）

**典型调用链**:
```
应用层 → Service → Driver → Device → BSP → HAL → 硬件寄存器
中断/DMA ← ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

必须分析：
- **调用者链**: 谁调用了当前模块？上层如何使用？
- **被调用者链**: 当前模块依赖哪些底层？BSP/Device 如何配置？
- **数据流向**: 数据从传感器到应用层的完整路径
- **完整数据使用链**（查找问题时必须追踪）:
  - 数据产生点：哪个 ISR/DMA/外设产生数据？
  - 数据处理链：经过哪些 Driver → Service → 应用层处理？
  - 数据消费点：最终被哪个任务/模块使用？
  - 异常影响范围：数据异常会影响哪些下游？
- **中断路径**: 中断触发源 → ISR → 回调 → 数据处理
- **DMA配置**: DMA 通道、内存段、对齐要求
- **配置依赖**: board_features、board_mapping、board_pins 的关联
- **时序约束**: 实时性要求、任务优先级、中断延迟
- **层职责边界检查**:
  - 当前修改是否在正确的层进行？
  - 是否存在跨层职责混淆（如 Driver 层直接操作 HAL）？
  - 是否存在反向依赖（如 BSP 依赖 Driver）？
  - 数据结构是否定义在正确位置（ST_XXX 在 data_structure.h）？

**⚠️ 问题定位原则**：

- 禁止只看当前报错位置就下结论
- 必须追踪数据从产生到出错的完整路径
- 找到真正的根因（可能在上游），而非表面症状

#### 方案设计原则：KISS

设计前必须回答4个问题：
1. **"这是真问题还是臆想的？"** - 拒绝过度设计
2. **"有更简单的方法吗？"** - 永远寻找最简方案
3. **"会破坏什么吗？"** - 向后兼容是铁律
4. **"真的需要这个功能吗？"** - 确认功能必要性

**性能要求（嵌入式特有）**：
- 最小化中断延迟
- 优先使用 DMA 传输
- 合理使用内存段（DTCM/AXI_SRAM）
- 避免不必要的数据复制

**代码简洁性**：
- 能用30行解决，绝不写300行
- 复用现有代码
- 函数职责单一

#### 数据驱动的方案设计（强制）

**所有方案必须有充足的数据支撑**：

数据充足性判断：
- ✅ 是否完整理解现有代码实现逻辑？
- ✅ 是否掌握硬件约束（时序、电气特性）？
- ✅ 是否了解内存/性能影响？
- ✅ 是否分析现有驱动的实现模式？
- ✅ 是否评估不同方案优劣？

**数据不足时的处理**：
```
⚠️ 我没有足够的信心设计最佳方案

需要以下数据：
1. [具体需要的数据1]
2. [具体需要的数据2]
...

请提供这些数据或告诉我如何获取。
```

**禁止**：
- ❌ 基于猜测或假设进行方案设计
- ❌ 数据不足时强行给出方案
- ❌ 使用"可能"、"也许"等不确定词汇描述关键决策

#### 方案审批流程（强制）

**在实施任何代码修改前，必须先获得用户审批**：

**工作流程**：
1. **分析阶段**：AI 使用只读工具（Read/Grep/Glob）深度分析代码
2. **方案设计**：制定详细的实施方案（见下方"方案文档要求"）
3. **展示方案**：向用户清晰展示方案，等待批准
4. **执行修改**：获得批准后才开始实际修改代码

**方案文档要求**：
1. **提交方案设计文档**，包含：
   - 完整调用链路分析
   - **层职责边界分析**（确认修改在正确的层，无跨层混淆）
   - 问题诊断和根因分析
   - **支撑数据和分析**（必须包含）
   - 方案设计（架构图、时序图、代码片段）
   - KISS原则4问题的回答
   - 内存/性能影响评估
   - 中断安全分析
   - 风险分析和缓解措施
   - **文档保存**: 保存到 `docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`

2. **等待用户确认** - 批准后方可开始实施

3. **实施** - 严格按照批准方案执行

#### 分析检查清单

开始编码前必须完成：
- [ ] 已完整追踪调用链路（Service → Driver → Device → BSP）
- [ ] 已理解所有涉及层的职责
- [ ] 已确认修改在正确的层进行，无跨层职责混淆
- [ ] 已检查无反向依赖（低层不依赖高层）
- [ ] 已识别所有数据转换点
- [ ] 已回答KISS原则4个问题
- [ ] 已收集充足数据支撑方案
- [ ] 已制定详细实施方案
- [ ] 已获得用户审批确认

---

### 2. 嵌入式代码风格规范

#### 2.1 接口设计模式（结构体+函数指针）

```c
// 驱动层 - 使用 handle 参数支持多实例
typedef struct {
    RY_RESULT (*init)(void *handle);
    RY_RESULT (*get_origin_data)(void *handle, ST_XXX *data);
    bool is_init_success;
} Drv_XXX;
extern Drv_XXX drv_xxx_1, drv_xxx_2;

// 服务层 - 通过 ID 路由到驱动实例
typedef struct {
    RY_RESULT (*init)(void);
    RY_RESULT (*get_origin_data)(const uint8_t id, ST_XXX *data);
    uint8_t (*get_supported_cnt)(void);
    bool (*is_sensor_initialized)(const uint8_t id);
} Srv_XXX;
extern Srv_XXX srv_xxx;
```

#### 2.2 数据结构规范

- 所有传感器数据结构定义在统一头文件（如 `data_structure.h`）
- 驱动层和服务层必须使用统一结构，禁止定义私有数据结构
- 示例: `ST_IMU`, `ST_MAG`, `ST_BARO`, `ST_GNSS`

#### 2.3 DRY（Don't Repeat Yourself）
- **原则**: 避免重复实现，优先复用现有代码
- **实践**: 添加任何新定义前，必须先用 `grep -r "functionName\|structName"` 检查是否已存在
- **目标**: 每个知识点在系统中只有唯一、明确的表达

#### 2.4 SoC（Separation of Concerns）
- **原则**: 关注点分离，不同关注点分离到不同层
- **实践**: 与层职责定义和调用链分析一致，明确各层边界
- **目标**: Service/Driver/Device/BSP 各司其职

---

### 3. 嵌入式健壮性原则

#### 3.1 中断安全
- 临界区保护：使用 `taskENTER_CRITICAL()` / `__disable_irq()`
- ISR 中禁止阻塞操作、禁止动态内存分配
- 共享数据必须使用原子操作或互斥保护
- ISR 执行时间尽量短，复杂处理交给任务

#### 3.2 内存安全
- DMA 缓冲区必须使用正确的内存段（如 `AXI_RAM_SECTION`）
- 注意内存对齐要求（如 32 字节对齐）
- 避免栈溢出，合理配置任务栈大小
- 静态分配优先，避免动态内存分配

#### 3.3 看门狗与故障恢复
- 系统级看门狗定期喂狗
- 关键任务设置独立监控
- HardFault 处理与错误日志记录
- 关键数据使用 CRC 校验

#### 3.4 外设操作规范
- 操作超时机制（避免死等）
- 外设初始化失败处理
- 资源释放与去初始化
- 状态机管理外设状态

---

### 4. 功能版本迭代限制

**禁止版本迭代**: 对于存量功能，严格禁止版本迭代（v1、v2、v3）

**核心原则**：
- **就地更新**: 所有改进必须直接修改现有代码
- **用户主导**: 只有用户明确要求才能创建新版本
- **单一实现**: 每个功能只能有一个实现版本
- **向后兼容**: 必须保持向后兼容
- **清理废弃**: 必须版本迭代时同时清理旧代码

---

### 5. 任务解析与影响分析

**任务前置分析原则**: 执行任何任务前，必须先进行全面分析

#### 文件影响评估
- **主要修改文件**: 直接需要编辑的核心文件
- **关联影响文件**: 可能受影响需同步更新的文件
- **配置文件**: board_pins.h、board_features.h、board_mapping.h
- **测试相关文件**: 需要更新或新增的测试文件

#### 依赖关系分析

- **层间依赖**: 识别跨层调用关系，确保单向依赖（Service → Driver → Device → BSP → Arch）
- **反向依赖检查**: 检查是否存在低层依赖高层的情况（严格禁止）
- **配置依赖**: 识别 board 配置的关联
- **层职责边界**: 确认每个修改点在正确的层实现

#### 重复定义检查

添加任何新定义前，必须先检查：
```bash
# 检查函数/结构体定义
grep -r "functionName\|ST_StructName" --include="*.c" --include="*.h"
```

**原则**: 避免重复实现，优先复用现有代码

---

## 关键配置文件

| 配置项 | 文件位置 |
|--------|----------|
| 芯片选择 | `platform/arch/interface/hal_adapter.h` |
| 内存段定义 | `platform/arch/interface/arch_memory.h` |
| 板型选择 | `platform/board/interface/board_config.h` |
| 引脚定义 | `platform/board/[chip]/[board]/board_pins.h` |
| 特性配置 | `platform/board/[chip]/[board]/board_features.h` |
| 设备映射 | `platform/board/[chip]/[board]/board_mapping.h` |
| 通用定义 | `platform/interface/ry_defines.h` |
| 数据结构 | `platform/interface/data_structure.h` |

---

## 内存配置

| 内存区域 | 大小 | 用途 | 宏 |
|----------|------|------|-----|
| DTCM | [大小] | 高速变量/栈 | `FAST_RAM_SECTION` |
| AXI_SRAM | [大小] | DMA缓冲 | `AXI_RAM_SECTION` |
| SRAM1/2 | [大小] | 通用数据 | - |

**使用规范**:
- DMA 缓冲区必须放在 AXI_SRAM
- 高频访问变量放在 DTCM
- 大数组考虑放在外部 SRAM（如有）

---

## 新增驱动/服务模板

**添加新驱动** (以 drv_xxx 为例):
1. 创建 `platform/driver/interface/drv_xxx.h`
2. 创建 `platform/driver/src/drv_xxx.c`
3. 在 `data_structure.h` 中添加 `ST_XXX` 数据结构（如需要）
4. 使用统一接口: `init()`, `set_id()`, `get_origin_data()`

**添加新服务** (以 srv_xxx 为例):
1. 创建 `platform/service/interface/srv_xxx.h`
2. 创建 `platform/service/src/srv_xxx.c`
3. 统一接口: `init()`, `get_origin_data(id, ST_XXX*)`, `get_supported_cnt()`, `is_sensor_initialized(id)`

---

## 文档资源

- `docs/架构分析报告.md` - 完整架构分析
- `docs/多芯片支持指南.md` - 多芯片支持指南
- `documents/drv-srv-style.md` - Driver/Service 编码规范
- `documents/comm_protocol.md` - 通信协议文档

---

## 交互规范（强制）

### 沟通原则
- **中文响应**: 所有响应使用中文
- **详细说明**: 提供清晰的操作步骤和说明
- **操作确认**: 重要操作前进行确认
- **透明度**: 如实汇报进度、问题和风险

### 主动提问机制（强制）
- **数据不足时提问**: 缺乏必要信息时，必须使用 `AskUserQuestion` 工具询问用户
- **明确性优先**: 遇到模糊需求时，通过提问明确用户意图
- **必须提问的场景**:
  - 技术方案有多种实现路径需权衡时
  - 需要删除或修改重要功能/数据时
  - 配置参数会显著影响系统行为时
  - 不确定用户具体需求时
  - 设计决策可能影响架构或性能时
  - 存在向后兼容性风险时
  - 涉及中断安全或内存安全的修改时
- **提问质量要求**:
  - 问题应具体、聚焦
  - 提供2-4个清晰选项
  - 每个选项附带详细说明
  - 说明各选项的影响和优缺点
- **等待确认**: 提问后必须等待用户回答

### 文件创建限制（强制）
- **禁止主动创建文档**: 不主动创建文档文件(*.md)或README，除非用户明确要求
- **优先编辑**: 优先编辑现有文件而非创建新文件
- **必要性原则**: 只创建绝对必要的文件
- **用户确认**: 创建新文件前必须征得用户同意

---

**最后更新**: [日期]
```

---

## 执行步骤

### 1. 前置检查

a. 检查当前目录是否已存在 CLAUDE.md 文件
   - 使用 Read 工具尝试读取 ./CLAUDE.md
   - 如果文件存在，使用 AskUserQuestion 询问用户是否要覆盖：
     - 选项 1: "备份后覆盖"（推荐） - 将现有文件备份为 CLAUDE.md.backup-{timestamp}
     - 选项 2: "直接覆盖" - 直接覆盖现有文件
     - 选项 3: "取消操作" - 退出命令
   - 如果用户选择取消，立即终止执行并输出提示信息

### 2. 项目分析（智能推断 - 嵌入式专用）

**核心原则**: 数据驱动，避免猜测。通过分析项目文件自动推断信息，减少用户输入负担。

#### a. 检测嵌入式项目类型

使用 Read 和 Glob 工具检查项目配置文件：

**Keil MDK 项目检测**:
```bash
检测文件: *.uvprojx, *.uvproj
提取信息:
  - 项目名称: 从 <ProjectName> 标签
  - MCU 型号: 从 <Device> 标签
  - 编译器: ARM Compiler 版本
  - 编译宏: 从 <Define> 标签
```

**IAR 项目检测**:
```bash
检测文件: *.ewp, *.eww
提取信息:
  - 项目名称
  - MCU 型号
  - 编译器版本
```

**CMake + GCC 项目检测**:
```bash
检测文件: CMakeLists.txt
提取信息:
  - 项目名称: project() 命令
  - MCU 型号: 从编译选项推断
  - 工具链: 从 CMAKE_TOOLCHAIN_FILE
```

**STM32CubeMX 项目检测**:
```bash
检测文件: *.ioc
提取信息:
  - MCU 型号
  - 外设配置
  - 时钟配置
```

#### b. 检测 RTOS

```bash
# FreeRTOS 检测
Glob: **/FreeRTOS*.h, **/freertos.h
Grep: "FreeRTOS" in *.c, *.h

# RT-Thread 检测
Glob: **/rtthread.h
Grep: "rt_thread" in *.c, *.h

# 裸机检测（无 RTOS）
如果以上都未检测到 → 裸机系统
```

#### c. 检测项目架构

```bash
# 检测分层架构
Glob: **/service/**/*.c, **/driver/**/*.c, **/device/**/*.c, **/bsp/**/*.c

# 检测 HAL 层
Glob: **/hal_*.c, **/stm32*_hal*.c

# 检测 Board 配置
Glob: **/board_*.h, **/board_pins.h, **/board_features.h
```

#### d. 收集配置信息（强制使用 AskUserQuestion 工具）

对于无法自动推断的信息，**必须**使用 `AskUserQuestion` 工具询问用户。

**第一步：询问用户称呼**（必须先执行）

使用 `AskUserQuestion` 工具询问：
```yaml
questions:
  - question: "您希望 AI 在每次回复时用什么称呼您？（例如：您好、Hi、或自定义昵称如 Kai）"
    header: "用户称呼"
    multiSelect: false
    options:
      - label: "您好"
        description: "正式的中文称呼"
      - label: "Hi"
        description: "轻松的英文问候"
      - label: "不需要称呼"
        description: "直接回答问题，不加称呼前缀"
```

> **注意**：用户可选择"其他"输入自定义称呼（如 Kai、老板、同学等）

**第二步：询问项目类型**

使用 `AskUserQuestion` 工具询问：
```yaml
questions:
  - question: "请选择项目的主要用途"
    header: "项目类型"
    multiSelect: false
    options:
      - label: "飞控/无人机"
        description: "飞行控制器、导航系统"
      - label: "工业控制"
        description: "PLC、运动控制、传感器采集"
      - label: "消费电子"
        description: "可穿戴设备、智能家居"
      - label: "通用嵌入式"
        description: "其他嵌入式应用"
```

### 3. 生成 CLAUDE.md

根据分析结果，使用内置模板生成 CLAUDE.md 文件：

1. **填充用户称呼**：将 `[用户称呼]` 替换为用户选择的称呼（如用户选择"不需要称呼"，则删除该行）
2. **填充项目概述**：使用检测到的 MCU、RTOS、框架信息
3. **填充架构信息**：根据检测到的目录结构生成架构图
4. **填充配置文件表**：列出检测到的关键配置文件
5. **填充命名规范**：根据检测到的代码风格
6. **填充 Skills 映射表**：根据项目类型填充适用的技能

### 4. 输出结果

```
✅ CLAUDE.md 生成完成！

📋 项目信息:
   - MCU: [检测到的 MCU 型号]
   - RTOS: [检测到的 RTOS]
   - 构建工具: [检测到的构建工具]
   - 架构模式: [检测到的架构模式]

📂 文件已创建: ./CLAUDE.md

💡 后续建议:
   1. 审查生成的 CLAUDE.md，根据实际情况调整
   2. 补充项目特有的规范和约束
   3. 更新 Skills 映射表中的可用技能
```

---

## 注意事项

1. **数据优先**: 优先使用项目实际数据，避免猜测
2. **按需询问**: 只对无法推断的信息询问用户
3. **嵌入式特化**: 模板针对嵌入式开发场景优化
4. **可扩展性**: 支持不同 MCU、RTOS、构建系统的检测
